<?php

/**
 * @file
 *   Hosting reserve functions, and Drupal hooks.
 */

define('HOSTING_RESERVE_DEFAULT_CLONE_DOMAIN', 'clone');

/**
 * Implementation of hook_menu().
 */
function hosting_reserve_menu() {
  $items['admin/hosting/reserve'] = array(
    'title' => 'Site Reserve',
    'description' => 'Configure settings for hosting site reserve',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_reserve_settings'),
    'access arguments' => array('administer modules'), // TODO find good permission
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Configuration form for hosting_reserve
 */
function hosting_reserve_settings() {
  $form['hosting_reserve_full_size'] = array(
    '#type' => 'textfield',
    '#title' => t('Full reserve size'),
    '#description' => t('The maximum number of sites in the reserve. The template will be cloned until this number is reached.'),
    '#default_value' => variable_get('hosting_reserve_full_size', '10'),
    '#required' => TRUE,
    '#weight' => -15,
  );

  $form['hosting_reserve_minimum_size'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum reserve size'),
    '#description' => t('The minimum number of sites in the reserve to try to preserve at all times. When there are fewer than this many reserve sites, we ignore the refilling time window restrictions (see lower). Set to zero to allow full depletion between time windows.'),
    '#default_value' => variable_get('hosting_reserve_minimum_size', '1'),
    '#weight' => -10,
  );

  $form['hosting_reserve_clone_life_time'] = array(
    '#type' => 'textfield',
    '#title' => t('Clone life time (in hours)'),
    '#description' => t('Set to zero for infinite. Clones will be deleted if they stay in the "reserve" this long. Clone deletion will only occur within the refill window.'),
    '#default_value' => variable_get('hosting_reserve_clone_life_time', '23'),
    '#weight' => -5,
  );

  $server_time_message = t('The current server time is @time', array('@time' => date("H:i")));


  $form['hosting_reserve_refill_window'] = array(
    '#type' => 'fieldset',
    '#title' => t('Time window for refilling'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#description' => t("Unless the reserve is depleted under the \"minimum reserve size\",  if you don't limit the hours, the reserve will always be refilling. This could slow down the time between request delivery if you have a few back-to-back, since clone and import tasks would run in-between the renaming tasks."),
    '#weight' => -1,
    '#prefix' => '<br/>',
    '#suffix' => '<br/>',
  );

  $form['hosting_reserve_refill_window']['hosting_reserve_refill_window_start'] = array(
    '#type' => 'textfield',
    '#title' => t('Start refilling the reserve at this hour.'),
    '#description' => t('Format: 00:00. ') . $server_time_message,
    '#default_value' => variable_get('hosting_reserve_refill_window_start', '00:00'),
    '#maxlength' => 5,
    '#size' => 6,
    '#prefix' => '<br/>',
  );

  $form['hosting_reserve_refill_window']['hosting_reserve_refill_window_end'] = array(
    '#type' => 'textfield',
    '#title' => t('Stop refilling the reserve at this hour.'),
    '#description' => t('Format: 23:59. ') . $server_time_message,
    '#default_value' => variable_get('hosting_reserve_refill_window_end', '04:00'),
    '#maxlength' => 5,
    '#size' => 6,
  );

  $form['#validate'][] = 'hosting_reserve_settings_form_validate';

  return system_settings_form($form);
}

function hosting_reserve_settings_form_validate(&$form, &$form_state) {
  $date_format = 'H:i';

  $values = $form_state['values'];

  if (!empty($values['hosting_reserve_refill_window_start'])) {
    if (strtotime($values['hosting_reserve_refill_window_start']) == 0) {
      form_set_error('hosting_reserve_refill_window_start', t('Invalid start time'));
    }
  }

  if (!empty($values['hosting_reserve_refill_window_end'])) {
    if (strtotime($values['hosting_reserve_refill_window_end']) == 0) {
      form_set_error('hosting_reserve_refill_window_end', t('Invalid end time'));
    }
  }

  if (empty($values['hosting_reserve_refill_window_start'])) {
    $form_state['values']['hosting_reserve_refill_window_start'] = '00:00';
  }

  if (empty($values['hosting_reserve_refill_window_end'])) {
    $form_state['values']['hosting_reserve_refill_window_end'] = '23:59';
  }

  if (empty($values['hosting_reserve_minimum_size'])) {
    $form_state['values']['hosting_reserve_minimum_size'] = '0';
  }
}

/**
 * Checks whether we are currently within the allowed time window for refilling
 * the site reserve.
 */
function hosting_reserve_is_allowed_time_window($time = NULL) {
  if ($time === NULL) {
    $time = time();
  }

  $today = date("D", time());

  $start_time = variable_get('hosting_reserve_refill_window_start', '00:00');
  $end_time = variable_get('hosting_reserve_refill_window_end', '04:00');

  // Date field shenanigans
  if (empty($start_time)) {
    $start_time = strtotime('00:00'); // Midnight "this morning"
  }
  else {
    $start_time = strtotime($start_time);
  }

  if (empty($end_time)) {
    $end_time = strtotime('23:59');
  }
  else {
    $end_time = strtotime($end_time);
  }

  if ($time < $start_time) {
    // Before the start time
    return FALSE;
  }

  if ($time > $end_time) {
    // After the end time
    return FALSE;
  }

  return TRUE;
}

/**
 * Get available clones.
 *
 * We ignore taken clones (ie clones with an alias).
 */
function hosting_reserve_get_clones($pattern = NULL) {
  if ($pattern == NULL) {
    $pattern = '%.' . HOSTING_RESERVE_DEFAULT_CLONE_DOMAIN;
  }

  $result = db_query("SELECT nid FROM node WHERE type = 'site' AND title LIKE '%s'", $pattern);

  $clones = array();
  while ($obj = db_fetch_object ($result)) {
    $node = node_load($obj->nid);

    // Exclude 'taken' clones
    if (empty($node->aliases)) {
      $clones[$obj->nid] = $node;
    }
  }

  return $clones;
}

/**
 * Deploys a new site, either from a reserve clone or by cloning the template.
 *
 * This is the main function to call to deploy a new site.
 */
function hosting_reserve_make_site($url) {
  // Get clones
  $clones = hosting_reserve_get_clones();

  if (!empty($clones)) {
    // Deploy first available clone
    $clone = array_shift($clones);
    hosting_reserve_alias_clone($url, $clone);

    return $clone;
  }
  else {
    // If no clones left, clone site as normal
    $error_message = '';
    hosting_saas_clone_site_from_template($url, $error_message);

    return $error_message;
  }
}

function hosting_reserve_alias_clone($url, $clone) {
  // TODO: Validate URL
  $clone->aliases[] = $url;

  node_save($clone); // This triggers a Verify
}

function hosting_reserve_migrate_clone($url, $clone) {
  // TODO
}

function hosting_reserve_make_clone() {
  // TODO : Create clone task
}

function hosting_reserve_cron() {
  watchdog('hosting_reserve', 'hosting_reserve_cron');

  // TODO: Also consider minimum reserve size
  if (hosting_reserve_is_allowed_time_window()) {
    // Check for expired clones and delete them
    // TODO: hosting_reserve_get_clones() etc.

    // Count the clones
    // TODO
    

    // Make a new clone if necessary
    // TODO
  }
}

function hosting_reserve_post_hosting_verify_task($task, $data) {
  drush_log('[hosting_reserve] hosting_reserve_post_hosting_verify_task');

  // TODO: Determine if the alias was just added

  // TODO: Implement hook to allow acting on site after it gets aliased
}
